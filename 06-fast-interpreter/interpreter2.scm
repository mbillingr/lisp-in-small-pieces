(import (builtin core)
        (libs utils)
        (libs book))

(define (meaning e r tail?)
  (if (atom? e)
      (if (symbol? e) (meaning-reference e r tail?)
                      (meaning-quotation e r tail?))
      (case (car e)
        ((quote)   (meaning-quotation (cadr e) r tail?))
        ((lambda)  (meaning-abstraction (cadr e) (cddr e) r tail?))
        ((if)      (meaning-alternative (cadr e) (caddr e) (cadddr e) r tail?))
        ((begin)   (meaning-sequence (cdr e) r tail?))
        ((set!)    (meaning-assignment (cadr e) (caddr e) r tail?))
        (else      (meaning-application (car e) (cdr e) r tail?)))))

(define (static-wrong message . culprits)
  (println `(*static-error* ,message . ,culprits))
  (lambda (sr k)
    (apply wrong message culprits)))

(define (deep-fetch sr i j)
  (if (= i 0)
      (activation-frame-argument sr j)
      (deep-fetch (environment-next sr) (- i 1) j)))

(define (deep-update! sr i j v)
  (if (= i 0)
      (set-activation-frame-argument! sr j v)
      (deep-update! (environment-next sr) (- i 1) j v)))

(define (r-extend* r n*)
  (cons n* r))

(define (local-variable? r i n)
  (define (scan names j)
    (cond ((pair? names) (if (eq? n (car names))
                             `(local ,i . ,j)
                             (scan (cdr names) (+ 1 j))))
          ((null? names) (local-variable? (cdr r) (+ i 1) n))
          ((eq? n names) `(local ,i . ,j))))

  (and (pair? r)
       (scan (car r) 0)))


(define (meaning-quotation v r tail?)
  (lambda (k) (k v)))

(define (meaning-alternative e1 e2 e3 r tail?)
  (let ((m1 (meaning e1 r #f))
        (m2 (meaning e2 r tail?))
        (m3 (meaning e3 r tail?)))
    (lambda (k)
      (m1 (lambda (v)
            ((if v m2 m3) k))))))

(define (meaning-sequence e+ r tail?)
  (if (pair? e+)
      (if (pair? (cdr e+))
          (meaning*-multiple-sequence (car e+) (cdr e+) r tail?)
          (meaning*-single-sequence (car e+) r tail?))
      (static-wrong "Illegal syntax: (begin)")))

(define (meaning*-single-sequence e r tail?)
  (meaning e r tail?))

(define (meaning*-multiple-sequence e e+ r tail?)
  (let ((m1 (meaning e r #f))
        (m+ (meaning-sequence e+ r tail?)))
    (lambda (k)
      (m1 (lambda (v)
            (m+ k))))))

(define (meaning-regular-application e e* r tail?)
  (let* ((m (meaning e r #f))
         (m* (meaning* e* r (length e*) #f)))
    (if tail?
        (lambda (k)
          (m (lambda (f)
               (if (procedure? f)
                   (m* (lambda (v*)
                         (f v* k)))
                   (wrong "Not a function" f)))))
        (lambda (k)
          (m (lambda (f)
               (if (procedure? f)
                   (m* (lambda (v*)
                         (let ((sr *env*))          ; save environment
                           (f v* (lambda (v)
                                   (set! *env* sr)  ; restore environment
                                   (k v))))))
                   (wrong "Not a function" f))))))))

(define (meaning* e* r size tail?)
  (if (pair? e*)
      (meaning-some-arguments (car e*) (cdr e*) r size tail?)
      (meaning-no-argument r size tail?)))

(define (meaning-no-argument r size tail?)
  (let ((size+1 (+ size 1)))
    (lambda (k)
      (let ((v* (allocate-activation-frame size+1)))
        (k v*)))))

(define (meaning-some-arguments e e* r size tail?)
  (let ((m (meaning e r #f))
        (m* (meaning* e* r size tail?))
        (rank (- size (+ (length e*) 1))))
    (lambda (k)
      (m (lambda (v)
           (m* (lambda (v*)
                 (set-activation-frame-argument! v* rank v)
                 (k v*))))))))

;(define (meaning-closed-application e ee* r)
;  (let ((nn* (cadr e)))
;    (define (parse n* e* regular)
;      (cond ((pair? n*)
;             (if (pair? e*)
;                 (parse (cdr n*) (cdr e*) (cons (car n*) regular))
;                 (static-wrong "Too few arguments" e ee*))
;            ((null? n*)
;             (if (null? e*)
;                 (meaning-fix-closed-application nn* (cddr e) ee* r)
;                 (static-wrong "Too many arguments" e ee*))
;            (else (meaning-dotted-closed-application
;                    (reverse regular) n* (cddr e) ee* r))))))
;    (parse nn* ee* '())))

;(define (meaning-fix-closed-application n* body e* r)
;  (let* ((m* (meaning* e* r (length e*)))
;         (r2 (r-extend* r n*))
;         (m+ (meaning-sequence body r2)))
;    (lambda (sr k)
;      (m* sr (lambda (v*)
;               (m+ (sr-extend* sr v*) k))))

(define (meaning-dotted-closed-application n* n body e* r)
  (let* ((m* (meaning-dotted* e* r (length e*) (length n*)))
         (r2 (r-extend* r (append n* (list n))))
         (m+ (meaning-sequence body r2)))
    (lambda (sr k)
      (m* sr (lambda (v*)
               (m+ (sr-extend* sr v*) k))))))

(define (meaning-dotted* e* r size arity)
  (if (pair? e*)
      (meaning-some-dotted-arguments (car e*) (cdr e*) r size arity)
      (meaning-no-dotted-argument r size arity)))

(define (meaning-some-dotted-arguments e e* r size arity)
  (let ((m (meaning e r))
        (m* (meaning-dotted* e* r size arity))
        (rank (- size (+ (length e*) 1))))
    (if (< rank arity)
        (lambda (sr k)
          (m sr (lambda (v)
                  (m* sr (lambda (v*)
                           (set-activation-frame-argument! v* rank v)
                           (k v*))))))
        (lambda (sr k)
          (m sr (lambda (v)
                  (m* sr (lambda (v*)
                           (set-activation-frame-argument!
                             v* arity
                             (cons v (activation-frame-argument v* arity)))
                           (k v*)))))))))

(define (meaning-no-dotted-argument r size arity)
  (let ((arity+1 (+ arity 1)))
    (lambda (sr k)
      (let ((v* (allocate-activation-frame arity+1)))
        (set-activation-frame-argument! v* arity '())
        (k v*)))))

(define (meaning-fix-abstraction n* e+ r tail?)
  (let* ((arity (length n*))
         (arity+1 (+ arity 1))
         (r2 (r-extend* r n*))
         (m+ (meaning-sequence e+ r2 #t)))
    (lambda (k)
      (let ((sr *env*))
        (k (lambda (v* k1)
             (if (= (activation-frame-argument-length v*) arity+1)
                 (begin (set! *env* (sr-extend* sr v*))
                        (m+ k1))
                 (wrong "Incorrect arity"))))))))

(define (meaning-dotted-abstraction n* n e+ r tail?)
  (let* ((arity (length n*))
         (arity+1 (+ arity 1))
         (r2 (r-extend* r (append n* (list n))))
         (m+ (meaning-sequence e+ r2 #t)))
    (lambda (k)
      (let ((sr *env*))
        (k (lambda (v* k1)
             (if (>= (activation-frame-argument-length v*) arity+1)
                 (begin (listify! v* arity)
                        (set! *env* (sr-extend* sr v*))
                        (m+ k1))
                 (wrong "Incorrect arity"))))))))

(define (listify! v* arity)
  (define (loop index result)
    (if (= arity index)
        (set-activation-frame-argument! v* arity result)
        (loop (- index 1)
              (cons (activation-frame-argument v* (- index 1))
                    result))))
  (loop (- (activation-frame-argument-length v*) 1) '()))

(define (meaning-abstraction nn* e+ r tail?)
  (define (parse n* regular)
    (cond ((pair? n*) (parse (cdr n*) (cons (car n*) regular)))
          ((null? n*) (meaning-fix-abstraction nn* e+ r tail?))
          (else (meaning-dotted-abstraction (reverse regular) n* e+ r tail?))))
  (parse nn* '()))

(define g.current '())
(define g.init '())

(define (compute-kind r n)
  (or (local-variable? r 0 n)
      (global-variable? g.current n)
      (global-variable? g.init n)))

(define (global-variable? g n)
  (let ((var (assq n g)))
    (and (pair? var) (cdr var))))

(define (g.current-extend! n)
  (let ((level (length g.current)))
    (set! g.current (cons (cons n `(global . ,level)) g.current))
    level))

(define (g.init-extend! n)
  (let ((level (length g.init)))
    (set! g.init (cons (cons n `(predefined . ,level)) g.init))
    level))

(define (definitial name value)
  (g.init-initialize! name value))

(define sg.current (make-vector 100))
(define sg.init (make-vector 100))
(define (global-fetch i)
  (vector-ref sg.current i))
(define (global-update! i v)
  (vector-set! sg.current i v))
(define (predefined-fetch i)
  (vector-ref sg.init i))

(define (g.current-initialize! name)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((global)
           (vector-set! sg.current (cdr kind) undefined-value))
          (else (static-wrong "Wrong redefinition" name)))
        (let ((index (g.current-extend! name)))
          (vector-set! sg.current index undefined-value))))
  name)

(define (g.init-initialize! name value)
  (let ((kind (compute-kind r.init name)))
    (if kind
        (case (car kind)
          ((predefined)
           (vector-set! sg.init (cdr kind) value))
          (else (static-wrong "Wrong redefinition" name)))
        (let ((index (g.init-extend! name)))
          (vector-set! sg.init index value))))
  name)

(define (meaning-reference n r tail?)
  (let ((kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)))
             (if (= i 0)
                 (lambda (k) (k (activation-frame-argument *env* j)))
                 (lambda (k) (k (deep-fetch *env* i j))))))
          ((global)
           (let ((i (cdr kind)))
             (if (eq? (global-fetch i) undefined-value)
                 (lambda (k)
                   (let ((v (global-fetch i)))
                     (if (eq? v undefined-value)
                         (wrong "Uninitialized variable" n)
                         (k v))))
                 (lambda (k) (k (global-fetch i))))))
          ((predefined)
           (let* ((i (cdr kind))
                  (value (predefined-fetch i)))
             (lambda (k) (k value)))))
        (static-wrong "No such variable" n))))

(define (meaning-assignment n e r tail?)
  (let ((m (meaning e r #f))
        (kind (compute-kind r n)))
    (if kind
        (case (car kind)
          ((local)
           (let ((i (cadr kind))
                 (j (cddr kind)))
             (if (= i 0)
                 (lambda (k)
                   (m (lambda (v)
                        (k (set-activation-frame-argument! *env* j v)))))
                 (lambda (k)
                   (m (lambda (v) (k (deep-update! *env* i j v))))))))
          ((global)
           (let ((i (cdr kind)))
             (lambda (k)
               (m (lambda (v) (k (global-update! i v)))))))
          ((predefined)
           (static-wrong "Immutable predefined variable" n)))
        (static-wrong "No such variable" n))))

(define (defprimitive name value arity)
  (case arity
    ((0) (defprimitive0 name value))
    ((1) (defprimitive1 name value))
    ((2) (defprimitive2 name value))
    ((3) (defprimitive3 name value))
    (else static-wrong "Unsupported primitive arity" name arity)))

(define (defprimitive0 name value)
  (definitial name
    (let* ((arity+1 (+ 0 1))
           (behavior
             (lambda (v* k)
               (if (= (activation-frame-argument-length v*) arity+1)
                   (k (value))
                   (wrong "Incorrect arity" name)))))
      (description-extend!
        name `(function ,value))
      behavior)))

(define (defprimitive1 name value)
  (definitial name
    (let* ((arity+1 (+ 1 1))
           (behavior
             (lambda (v* k)
               (if (= (activation-frame-argument-length v*) arity+1)
                   (k (value (activation-frame-argument v* 0)))
                   (wrong "Incorrect arity" name)))))
      (description-extend!
        name `(function ,value a))
      behavior)))

(define (defprimitive2 name value)
  (definitial name
    (let* ((arity+1 (+ 2 1))
           (behavior
             (lambda (v* k)
               (if (= (activation-frame-argument-length v*) arity+1)
                   (k (value (activation-frame-argument v* 0)
                             (activation-frame-argument v* 1)))
                   (wrong "Incorrect arity" name)))))
      (description-extend!
        name `(function ,value a b))
      behavior)))

(define (defprimitive3 name value)
  (definitial name
    (let* ((arity+1 (+ 3 1))
           (behavior
             (lambda (v* k)
               (if (= (activation-frame-argument-length v*) arity+1)
                   (k (value (activation-frame-argument v* 0)
                             (activation-frame-argument v* 1)
                             (activation-frame-argument v* 2)))
                   (wrong "Incorrect arity" name)))))
      (description-extend!
        name `(function ,value a b c))
      behavior)))

(define desc.init '())
(define (description-extend! name description)
  (set! desc.init (cons (cons name description) desc.init))
  name)
(define (get-description name)
  (let ((p (assq name desc.init)))
    (and (pair? p) (cdr p))))

(define (meaning-application e e* r tail?)
  (cond
    ((and (symbol? e)
          (let ((kind (compute-kind r e)))
            (and (pair? kind)
                 (eq? 'predefined (car kind))
                 (let ((desc (get-description e)))
                   (and desc
                        (eq? 'function (car desc))
                        (if (= (length (cddr desc)) (length e*))
                            (meaning-primitive-application e e* r tail?)
                            (static-wrong "Incorrect arity for" e))))))))
    ;((and (pair? e)
    ;      (eq? 'lambda (car e)))
    ; (meaning-closed-application e e* r))
    (else (meaning-regular-application e e* r tail?))))

(define (meaning-primitive-application e e* r tail?)
  (let* ((desc (get-description e)) ;desc = (function address . var-list)
         (address (cadr desc))
         (size (length e*)))
    (case size
      ((0) (lambda (k) (k (address))))
      ((1) (let ((m1 (meaning (car e*) r #f)))
             (lambda (k)
               (m1 (lambda (v) (k (address v)))))))
      ((2) (let ((m1 (meaning (car e*) r #f))
                 (m2 (meaning (cadr e*) r #f)))
             (lambda (k)
               (m1 (lambda (v1)
                     (m2 (lambda (v2) (k (address v1 v2)))))))))
      ((3) (let ((m1 (meaning (car e*) r #f))
                 (m2 (meaning (cadr e*) r #f))
                 (m3 (meaning (caddr e*) r #f)))
             (lambda (k)
               (m1 (lambda (v1)
                     (m2 (lambda (v2)
                           (m3 (lambda (v3) (k (address v1 v2 v3)))))))))))
      (else (meaning-regular-application e e* r tail?)))))


(define (sr-extend* sr v*)
  (set-environment-next! v* sr)
  v*)

(define r.init '())
(define sr.init '())

(define *env* sr.init)

(define (chapter62-interpreter)
  (define (toplevel)
    (set! *env* sr.init)
    ((meaning (read) r.init #t) display)
    (toplevel))
  (toplevel))

(define undefined-value '*undefined*)

(g.current-initialize! 'x)
(g.current-initialize! 'y)
(g.current-initialize! 'z)
(g.current-initialize! 'foo)
(g.current-initialize! 'bar)

(definitial 't #t)
(definitial 'f #f)
(definitial 'nil '())
(defprimitive 'cons cons 2)
(defprimitive 'car car 1)
(defprimitive 'cdr cdr 1)
(defprimitive 'eq? eq? 2)
(defprimitive '= = 2)
(defprimitive '+ + 2)
(defprimitive '- - 2)
(defprimitive '* * 2)
(defprimitive '/ / 2)
(definitial 'call/cc
  (let* ((arity 1)
         (arity+1 (+ arity 1)))
    (lambda (v* k)
      (if (= arity+1 (activation-frame-argument-length v*))
          ((activation-frame-argument v* 0)
           (let ((frame (allocate-activation-frame (+ 1 1))))
             (set-activation-frame-argument!
               frame 0
               (lambda (values kk)
                 (if (= (activation-frame-argument-length values) arity+1)
                     (k (activation-frame-argument values 0))
                     (wrong "Incorrect arity" 'continuation))))
             frame)
           k)
          (wrong "Incorrect arity" 'call/cc)))))


; The following implementations are not defined in the book, so I'm making them up...

(define (environment-next frame)
  (car frame))

(define (set-environment-next! frame sr)
  (set-car! frame sr))

(define (allocate-activation-frame size)
  (list '() (make-vector size) size))

(define (activation-frame-argument frame index)
  (vector-ref (cadr frame) index))

(define (set-activation-frame-argument! frame index value)
  (vector-set! (cadr frame) index value))

(define (activation-frame-argument-length frame)
  (caddr frame))
