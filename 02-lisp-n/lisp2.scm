(import (builtin core)
        (libs utils)
        (libs book))

(define (f.evaluate e env fenv)
  (if (atom? e)
      (cond ((symbol? e) (lookup e env))
            ((or (number? e) (string? e) (char? e) (boolean? e))
             e)
            (else (wrong "Cannot evaluate" e)))
      (case (car e)
        ((quote)  (cadr e))
        ((if)     (if (f.evaluate (cadr e) env fenv)
                      (f.evaluate (caddr e) env fenv)
                      (f.evaluate (cadddr e) env fenv)))
        ((begin)  (f.eprogn (cdr e) env fenv))
        ((set!)   (update! (cadr e)
                           env
                           (f.evaluate (caddr e) env fenv)))
        ((lambda) (f.make-function (cadr e) (cddr e) env fenv))
        ((function)
         (cond ((symbol? (cadr e))
                (f.lookup (cadr e) fenv))
               ((and (pair? (cadr e)) (eq? (car (cadr e)) 'lambda))
                (f.make-function
                  (cadr (cadr e)) (cddr (cadr e)) env fenv))
               (else (wrong "Incorrect function" (cadr e)))))
        ((flet)
         (f.eprogn (cddr e)
                   env
                   (extend fenv
                           (map car (cadr e))
                           (map (lambda (def)
                                  (f.make-function (cadr def) (cddr def)
                                                   env fenv))
                                (cadr e)))))
        ((labels)
         (let ((new-fenv (extend fenv
                                 (map car (cadr e))
                                 (map (lambda (def) 'void) (cadr e)))))
            (for-each (lambda (def)
                        (update! (car def)
                                 new-fenv
                                 (f.make-function (cadr def) (cddr def)
                                                  env new-fenv)))
                      (cadr e))
            (f.eprogn (cddr e) env new-fenv)))
        (else     (f.evaluate-application (car e)
                                          (f.evlis (cdr e) env fenv)
                                          env
                                          fenv)))))

(define (f.evaluate-application fn args env fenv)
  (cond ((symbol? fn)
         ((f.lookup fn fenv) args))
        ((and (pair? fn) (eq? (car fn) 'lambda))
         (f.eprogn (cddr fn)
                   (extend env (cadr fn) args)
                   fenv))
        (else (wrong "Incorrect functional term" fn))))

(define (f.lookup id fenv)
  (if (pair? fenv)
      (if (eq? (caar fenv) id)
          (cdar fenv)
          (f.lookup id (cdr fenv)))
      (lambda (values)
        (wrong "No such functional binding" id))))

(define (f.evlis exps env fenv)
  (if (pair? exps)
      (cons (f.evaluate (car exps) env fenv)
            (f.evlis (cdr exps) env fenv))
      '()))

(define (f.eprogn exps env fenv)
  (if (pair? exps)
      (if (pair? (cdr exps))
          (begin (f.evaluate (car exps) env fenv)
                 (f.eprogn (cdr exps) env fenv))
          (f.evaluate (car exps) env fenv))
      empty-begin))

(define (f.make-function variables body env fenv)
  (lambda (values)
    (f.eprogn body (extend env variables values) fenv)))

(define env.global '())
(define fenv.global '())

(define (definitial name . value)
  (if (null? value)
      (begin (set! env.global (cons (cons name 'void) env.global))
             name)
      (begin (set! env.global (cons (cons name (car value)) env.global))
             name)))

(define (definitial-function name . value)
  (if (null? value)
      (set! fenv.global (cons (cons name 'void) fenv.global))
      (set! fenv.global (cons (cons name (car value)) fenv.global))))

(define (defprimitive name value arity)
  (definitial-function name
    (lambda (values)
      (if (= arity (length values))
          (apply value values)
          (wrong "Incorrect arity" (list name values))))))

(definitial 't #t)
(definitial 'f #f)
(definitial 'nil '())

(definitial 'foo)
(definitial 'bar)
(definitial 'fib)
(definitial 'fact)
(definitial 'list)

(defprimitive 'cons cons 2)
(defprimitive 'car car 1)
(defprimitive 'cdr cdr 1)
(defprimitive 'set-car! set-car! 2)
(defprimitive 'set-cdr! set-cdr! 2)
(defprimitive '+ + 2)
(defprimitive '- - 2)
(defprimitive '* * 2)
(defprimitive '/ / 2)
(defprimitive 'eq? eq? 2)
(defprimitive '< < 2)

(definitial-function 'funcall
  (lambda (args)
    (if (> (length args) 1)
        (invoke (car args) (cdr args))
        (wrong "Incorrect arity" 'funcall))))

(define (lisp2-repl)
  (define (toplevel)
    (display (f.evaluate (read) env.global fenv.global))
    (toplevel))
  (toplevel))

(lisp2-repl)
